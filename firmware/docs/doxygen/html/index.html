<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Millimeter Wave (mmw) Demo for XWR16XX</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Millimeter Wave (mmw) Demo for XWR16XX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<div class="image">
<img src="toplevel.png" alt="toplevel.png"/>
</div>
<p>The millimeter wave demo shows some of the capabilities of the XWR16xx SoC using the drivers in the mmWave SDK (Software Development Kit). It allows user to specify the chirping profile and displays the detected objects and other information in real-time.</p>
<p>Following is a high level description of the features of this demo:</p><ul>
<li>Be able to specify desired chirping profile through command line interface (CLI) on a UART port or through the TI Gallery App - <b>mmWave Demo Visualizer</b> - that allows user to provide a variety of profile configurations via the UART input port and displays the streamed detected output from another UART port in real-time, as seen in picture above.</li>
<li>Some sample profile configurations have been provided in the demo directory that can be used with CLI directly or via <b>mmWave Demo Visualizer</b>: <pre class="fragment">    mmw/profiles/profile_2d.cfg
    mmw/profiles/profile_2d_srr.cfg
    mmw/profiles/profile_heat_map.cfg</pre></li>
<li>Do 1D, 2D, CFAR and Azimuth processing and stream out velocity and two spatial coordinates (x,y) of the detected objects in real-time. The demo can also be configured to do 2D only detection (velocity and x,y coordinates).</li>
<li>Various display options besides object detection like azimuth heat map and Doppler-range heat map.</li>
<li>Illustrates how to configure the various hardware entities ( EDMA, UART) in the AR SoC using the driver software.</li>
</ul>
<h1><a class="anchor" id="limit"></a>
Limitations</h1>
<ul>
<li>Because of UART speed limit (&lt; 1 Mbps), the frame time is more restrictive. For example, for the azimuth and Doppler heat maps for 256 FFT range and 16 point FFT Doppler, it takes about 200 ms to transmit.</li>
<li>Present implementation in this demo can resolve up to two objects in the azimuth dimension which have the same range and same velocity.</li>
<li>Code will give an error if the requested memory in L3 RAM exceeds its size (<a class="el" href="group___s_o_c___x_w_r16_x_x___d_s_s___b_a_s_e___a_d_d_r_e_s_s.html#ga6c76ef2d5003152328d71695f98d2c1a">SOC_XWR16XX_DSS_L3RAM_SIZE</a>) due to particular combination of CLI configuration parameters.</li>
<li>For most boards, a range bias of few centimeters has been observed. User can estimate the range bias on their board and correct using the calibration procedure described in <a class="el" href="index.html#calibration">Range Bias and Rx Channel Gain/Offset Measurement and Compensation</a>.</li>
</ul>
<h1><a class="anchor" id="tasks"></a>
System Details</h1>
<p>The millimeter wave demo runs on both R4F (MSS) and C674x (DSS). System startup is described in the following diagram:</p>
<div class="image">
<img src="system_startup.png" alt="system_startup.png"/>
<div class="caption">
System Startup</div></div>
<h2><a class="anchor" id="mss_tasks"></a>
Software Tasks on MSS</h2>
<p>The following (SYSBIOS) tasks are running on MSS:</p><ul>
<li><a class="el" href="mss__main_8c.html#ab9d0eb98975dced9a9ebb9225d338f0d">MmwDemo_mssInitTask</a>. This task is created and launched by <a class="el" href="mss__main_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> and is a one-time initialization task that performs the following sequence:<ol type="1">
<li>Initializes drivers (&lt;driver&gt;_init).</li>
<li>Initializes the MMWave module (MMWave_init)</li>
<li>Creates/launches the following tasks (the <a class="el" href="utils_2cli_2src_2cli_8c.html#a96a82b05d16ca58d5c4f7ade7f0df74f">CLI_task</a> is launched indirectly by calling <a class="el" href="utils_2cli_2src_2cli_8c.html#a664861a70519c2c7c5e4091b1a0958f2">CLI_open</a>).</li>
</ol>
</li>
<li><a class="el" href="mss__main_8c.html#a704f8c65125047f85b3ced585f4f58f1">MmwDemo_mmWaveCtrlTask</a>. This task is used to provide an execution context for the mmWave control, it calls in an endless loop the MMWave_execute API.</li>
<li><a class="el" href="mss__main_8c.html#a65c7a249cb1b6e0a03c64a8581de032d">MmwDemo_mssCtrlPathTask</a>. The task is used to process data path events coming from the <a class="el" href="utils_2cli_2src_2cli_8c.html#a96a82b05d16ca58d5c4f7ade7f0df74f">CLI_task</a> or start/stop events coming from <a class="el" href="gpio__xwr16xx_8h.html#a196cd0c4345217dd37eff07155083fc8">SOC_XWR16XX_GPIO_1</a> button on EVM. It signals the start/stop completion events back to <a class="el" href="utils_2cli_2src_2cli_8c.html#a96a82b05d16ca58d5c4f7ade7f0df74f">CLI_task</a>.</li>
<li><a class="el" href="utils_2cli_2src_2cli_8c.html#a96a82b05d16ca58d5c4f7ade7f0df74f">CLI_task</a>. This CLI task takes user commands and posts events to the <a class="el" href="mss__main_8c.html#a65c7a249cb1b6e0a03c64a8581de032d">MmwDemo_mssCtrlPathTask</a>. In case of start/stop commands, it waits for the completion events from <a class="el" href="mss__main_8c.html#a65c7a249cb1b6e0a03c64a8581de032d">MmwDemo_mssCtrlPathTask</a> and on success, it toggles the LED <a class="el" href="gpio__xwr16xx_8h.html#a2bbc4bb4de357cc59dc76a1676e893ef">SOC_XWR16XX_GPIO_2</a>.</li>
<li><a class="el" href="mss__main_8c.html#a14609ef74e9a059ce0e29edfa80c907c">MmwDemo_mboxReadTask</a>. This task handles mailbox messages received from DSS.</li>
</ul>
<h2><a class="anchor" id="dss_tasks"></a>
Software Tasks on DSS</h2>
<p>The following four (SYSBIOS) tasks are running on DSS:</p><ul>
<li><a class="el" href="dss__main_8c.html#a4ad6f3ad3da43b07c76540d0c9c09e07">MmwDemo_dssInitTask</a>. This task is created/launched by main (in <a class="el" href="dss__main_8c.html">dss_main.c</a>) and is a one-time active task that performs the following sequence:<ol type="1">
<li>Initializes drivers (&lt;driver&gt;_init).</li>
<li>Initializes the MMWave module (MMWave_init)</li>
<li>Creates/launches the other three tasks.</li>
</ol>
</li>
<li><a class="el" href="mss__main_8c.html#a14609ef74e9a059ce0e29edfa80c907c">MmwDemo_mboxReadTask</a>. This task handles mailbox messages received from MSS.</li>
<li><a class="el" href="dss__main_8c.html#a48ec45565d314bf8443ccb2b319f0edc">MmwDemo_dssMMWaveCtrlTask</a>. This task is used to provide an execution context for the mmWave control, it calls in an endless loop the MMWave_execute API.</li>
<li><p class="startli"><a class="el" href="dss__main_8c.html#a6ff98f1865ac192b310c3f7d1ce150a6">MmwDemo_dssDataPathTask</a>. The task performs in real-time:</p><ul>
<li>Data path processing chain control and (re-)configuration of the hardware entities involved in the processing chain, namely EDMA.</li>
<li>Data path signal processing such as range, Doppler and azimuth DFT, object detection, and direction of arrival calculation.</li>
<li>Transfers detected objects to the HS-RAM shared memory and informs MSS that the data is ready to be sent out to through the UART output port. For format of the data on UART output port, see <a class="el" href="dss__main_8c.html#a3f542b36e5bc2ce609fe3722b7843bc9">MmwDemo_dssSendProcessOutputToMSS</a>. The UART transmission is done on MSS.</li>
</ul>
<p class="startli">The task pends on the following events:</p><ul>
<li><a class="el" href="dss__mmw_8h.html#afa9033dc75695d35a14aa79e1c20a521">MMWDEMO_CONFIG_EVT</a>. This event is posted by <a class="el" href="dss__main_8c.html#a7a2edd82c103d67f382663e4ad499cda">MmwDemo_dssMmwaveConfigCallbackFxn</a> which in called by MMWAVE_ API triggered when MSS issues MMWAVE_config</li>
<li><a class="el" href="dss__mmw_8h.html#a5e38e363fb285141dacce6e8ef7f6c76">MMWDEMO_BSS_STOP_COMPLETE_EVT</a>. This event is posted by <a class="el" href="dss__main_8c.html#ad34e568ca397b38942029ed1bc486b92">MmwDemo_dssMmwaveEventCallbackFxn</a> when the Frame Stop asynchronous event is received. Details as follows: Initially MSS receives the CLI sensorStop command and issues a stop command to BSS. Once BSS fully stops the frame processing, BSS sends a "Frame Stopped Asynchronous event" to MSS. MSS then forwards the "Frame Stopped Asynchronous event" to DSS, where it is handled by <a class="el" href="dss__main_8c.html#ad34e568ca397b38942029ed1bc486b92">MmwDemo_dssMmwaveEventCallbackFxn</a>. This event causes DSS to go in <a class="el" href="dss__mmw_8h.html#a954ae46b578dfac30faffeaa36ddc5eea6e640857902d92fbdd68fc0d325f0cf4">MmwDemo_DSS_STATE_STOP_PENDING</a> state. If DSS received the "Frame Stopped Asynchronous event" after the inter-frame processing is completed, it will post MMWDEMO_STOP_COMPLETE_EVT. Otherwise, it will wait to finish the inter-frame processing before posting MMWDEMO_STOP_COMPLETE_EVT. See MMWDEMO_STOP_COMPLETE_EVT event below for more details.</li>
<li><a class="el" href="dss__mmw_8h.html#adbfffd982f90f949de478536dccf152b">MMWDEMO_FRAMESTART_EVT</a>. This event originates from BSS firmware and indicates the beginning of the radar frame. It is posted by interrupt handler function <a class="el" href="dss__main_8c.html#aaf19fa75806ecfb61b0fc8ec3249a30a">MmwDemo_dssFrameStartIntHandler</a>.</li>
<li><a class="el" href="dss__mmw_8h.html#a6a5beb99522667955a91f486bdf35c28">MMWDEMO_CHIRP_EVT</a>. This event originates from BSS firmware and indicates that the ADC buffer, (ping or pong) is filled with ADC samples. It is posted by <a class="el" href="dss__main_8c.html#aaf8e8170f13e5461a2023c605a45127b">MmwDemo_dssChirpIntHandler</a>.</li>
<li><a class="el" href="dss__mmw_8h.html#a52829cd0f2764ea388b203b5a1bfa8b8">MMWDEMO_START_EVT</a>. This event is posted by <a class="el" href="dss__main_8c.html#aea837f391a7c1fc3979e9a8c9d4dbc93">MmwDemo_dssMmwaveStartCallbackFxn</a> when MMWave_start is called from MSS (on CLI sensorStart 0 command which means starts with no reconfiguration)</li>
<li><a class="el" href="dss__mmw_8h.html#a17e314d821120e2698e882260b981ba1">MMWDEMO_STOP_COMPLETE_EVT</a>. This event is posted either when the MMWDEMO_BSS_STOP_COMPLETE_EVT is received after the inter-frame processing has ended or when the ongoing active frame finishes sending data over UART. This event now moves the DSS to MmwDemo_DSS_STATE_STOP state and executes <a class="el" href="dss__main_8c.html#a19ecaecc70be5ee3fbf49c78fe03c5de">MmwDemo_dssDataPathStop</a> which further sends <a class="el" href="mmw__messages_8h.html#a0efd487a29c3b8585d84f74188a4c04fa2d9c0e22d829c8d37552ce341ceb560a">MMWDEMO_DSS2MSS_STOPDONE</a> message back to MSS.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="datapathtop"></a>
Data Path</h1>
<h2><a class="anchor" id="datapath"></a>
Data Path - Overall</h2>
<div class="image">
<img src="datapath_overall.png" alt="datapath_overall.png"/>
<div class="caption">
Top Level Data Path Processing Chain</div></div>
<p> <br />
 <br />
 </p><div class="image">
<img src="datapath_overall_timing.png" alt="datapath_overall_timing.png"/>
<div class="caption">
Top Level Data Path Timing</div></div>
<p> As seen in the above picture, the data path processing consists of:</p><ul>
<li>Processing during the chirps as seen in the timing diagram. This consists of<ul>
<li>1D (range) FFT processing performed by C674x that takes input from multiple receive antennas from the ADC buffer for every some number of chirps (corresponding to the chirping pattern on the transmit antennas), and</li>
<li>transferring output into the L3 RAM by EDMA. More details can be seen in <a class="el" href="index.html#data1d">Data Path - 1st Dimension FFT Processing</a></li>
</ul>
</li>
<li>Processing during the time between the end of chirps until the beginning of the next chirping period, shown as "Inter Frame Period" in the timing diagram. This processing consists of:<ul>
<li>2D (velocity) FFT processing performed by C674x that reads input from 1D output in L3 RAM in a transposed manner (using EDMA) and performs FFT to give a (range,velocity) matrix in the L3 RAM. The processing also includes the CFAR detection in Doppler direction. More details can be seen in <a class="el" href="index.html#data2d">Data Path - 2nd Dimension FFT Processing</a>.</li>
<li>CFAR detection in range direction using mmWave library.</li>
<li>Peak Grouping if enabled.</li>
<li>Direction of Arrival (Azimuth) Estimation. More details can be seen at <a class="el" href="index.html#dataAngElev">Data Path - Direction of Arrival FFT Calculation</a> and <a class="el" href="index.html#dataXYZ">Data Path - (X,Y) Estimation</a> </li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="advanced"></a>
Advanced Frame - Sub Frame Processing</h3>
<div class="image">
<img src="datapath_overall_timing_subframe.png" alt="datapath_overall_timing_subframe.png"/>
<div class="caption">
Top Level Data Path Timing for sub-frames</div></div>
<p> <br />
 <br />
 In advanced frame mode, sub-frame processing is supported for which the datapath is essentially same as described in <a class="el" href="index.html#datapath">Data Path - Overall</a> except that there is sub-frame switching related processing required to prepare for next sub-frame as seen in above diagram. The details of what is involved in sub-frame switching are described in <a class="el" href="index.html#subFrameSwitching">Sub-frame Switching for Advanced Frame</a>. The data path for each sub-frame is independent of other sub-frames i.e there is no combining of information across sub-frames - each sub-frame's results are sent out to the host after the completion of its data path processing in real-time.</p>
<h2><a class="anchor" id="antConfig"></a>
Antenna Configurations</h2>
<p>The following figure shows antenna layout as seen from the front of the EVM xWR16xx board alongside the x,y coordinate convention. </p><div class="image">
<img src="antenna_design.png" alt="antenna_design.png"/>
<div class="caption">
AWR16xx Antenna layout</div></div>
<p> As seen in figures below, the millimeter wave demo supports two antenna configurations:</p><ul>
<li>Single transmit antenna and four receive antennas.</li>
<li>Two transmit antennas and four receive antennas. Transmit antennas Tx1 and Tx2 are horizontally spaced at d = 2 Lambda, with their transmissions interleaved in a frame <div class="image">
<img src="antenna_layout_simo.png" alt="antenna_layout_simo.png"/>
<div class="caption">
Single Tx Antenna Configuration</div></div>
 <br />
 <div class="image">
<img src="antenna_layout_mimo.png" alt="antenna_layout_mimo.png"/>
<div class="caption">
TDM-MIMO Antenna Configuration</div></div>
 <br />
 Both configurations allow for azimuth estimation.</li>
</ul>
<h2><a class="anchor" id="data1d"></a>
Data Path - 1st Dimension FFT Processing</h2>
<div class="image">
<img src="datapath_1d_tdm_mimo.png" alt="datapath_1d_tdm_mimo.png"/>
<div class="caption">
Data Path 1D for TDM-MIMO configuration</div></div>
<p> <br />
 Above picture illustrates 1D chirp processing for the case with one chirp (interrupt) event for every two chirps and two transmit antennas, (TDM-MIMO case), as mentioned in <a class="el" href="index.html#antConfig">Antenna Configurations</a>. There are 4 rx antennas, the samples of which are color-coded and labeled as 1,2,3,4 with unique coloring for each of chirps that are processed in ping-pong manner. The 1D FFT chirp processing is triggered by hardware chirp event generated when the ADC has samples to process in the ADC buffer Ping or Pong memories. The hardware event triggers the registered chirp event interrupt handler function <a class="el" href="dss__main_8c.html#aaf8e8170f13e5461a2023c605a45127b">MmwDemo_dssChirpIntHandler</a>, that in turn posts <a class="el" href="dss__mmw_8h.html#a6a5beb99522667955a91f486bdf35c28">MMWDEMO_CHIRP_EVT</a> to <a class="el" href="dss__main_8c.html#a6ff98f1865ac192b310c3f7d1ce150a6">MmwDemo_dssDataPathTask</a>. The task initiates EDMA transfer of rx antenna samples in a ping pong manner to parallelize C674x processing with EDMA data transfer from ADC buffer to L2 memory. The processing includes FFT calculation using DSP library function with 16-bit input and output precision. Before FFT calculation, a Blackman window is applied to ADC samples using mmwlib library function. The calculated 1D FFT samples are EDMA transferred to the radar cube matrix in L3 memory. One column of the radar cube matrix contains 1D-FFT samples of chirps corresponding to the two transmit antennas and in this (TDM) case, all chirps corresponding to Tx1 are stored consecutively followed by those corresponding to Tx2. The reason for storing in this way instead of time of arrival order (Tx1,Tx2,Tx1,Tx2..) is to prevent EDMA jump for 1D output and 2D input from exceeding the EDMA jump limit. The EDMA jumps (source and destination B/C indices) are 16-bit signed, so when number of range bins is 1024 and number of receive antennas is 4, the jump becomes 1024*4*4(bytes/sample)*2(Tx1,Tx2 order) = 32768 which is -32768 as signed 16-bit. While the jump in 1D output can be overcome by setting the destination address in the compute loop every chirp output EDMA trigger (which is not too significant burden in cycles), the 2D cannot be overcome this way without breaking the very purpose of EDMA-CPU parallelism because the source address would have to be reprogrammed every sample! The jump is halved (16384) when storing all Tx1 consecutively followed by all Tx2 consecutively. Picture below illustrates the shape of radar cube matrix for one Tx antenna configuration, where one column contains 1D FFT samples of one chirp.</p>
<div class="image">
<img src="datapath_1d_simo_radar_cube.png" alt="datapath_1d_simo_radar_cube.png"/>
<div class="caption">
Radar cube matrix for single Tx antenna configuration</div></div>
<p> <br />
 The timing diagram of chirp processing is illustrated in figure below. </p><div class="image">
<img src="datapath_1d_timing.png" alt="datapath_1d_timing.png"/>
<div class="caption">
Data Path 1D timing diagram</div></div>
<p> <br />
 </p>
<h3><a class="anchor" id="calibDC_Range"></a>
Antenna coupling signature removal</h3>
<div class="image">
<img src="antenna_coupling_signature_removal.png" alt="antenna_coupling_signature_removal.png"/>
<div class="caption">
Antenna coupling signature removal</div></div>
<p> Antenna coupling signature dominates the range bins close to the radar. These are the bins in the range FFT output located around DC. This feature is under user control in terms of enable/disable and start/end range bins through a CLI command called calibDcRangeSig. During measurement (when the CLI command is issued with feature enabled), each of the specified range bins for each of the virtual antennas are accumulated over the specified number of chirps and at the end of the period, the average is computed for each bin/antenna combination for removal after the measurement period is over. Note that the number of chirps to average must be power of 2. It is assumed that no objects are present in the vicinity of the radar during this measurement period. After measurement is done, the removal starts for all subsequent frames during which each of the bin/antenna average estimate is subtracted from the corresponding received samples in real-time for subsequent processing.</p>
<h2><a class="anchor" id="data2d"></a>
Data Path - 2nd Dimension FFT Processing</h2>
<p>The 2D processing consists of the following steps:</p><ol type="1">
<li>For each range bin it performs:<ul>
<li>Static clutter removal if enabled. The mean value of the input samples to the 2D-FFT is subtracted from the samples,</li>
<li>Windowing - samples are multiplied by a window function,</li>
<li>2D-FFT on the samples of 1D-FFT output across chirps (samples are transposed by the EDMA before 2D FFT can be performed),</li>
<li>log2 magnitude of the output,</li>
<li>accumulation across all Rx antennas,</li>
<li>transfer of accumulated values to detection matrix in L3 using EDMA,</li>
<li>CFAR pre-detection in Doppler direction and saving of Doppler indices of detected objects for the final CFAR detection in the range direction.</li>
</ul>
</li>
<li>Final CFAR detection in range direction at Doppler indices at which objects were detected in previous step</li>
<li>Peak grouping. Grouping options are specified by CLI CFAR configuration function and can be<ul>
<li>in both range and Doppler direction,</li>
<li>only in range,</li>
<li>only in Doppler direction, or</li>
<li>none. <br />
The 2D processing is shown in figures below.</li>
</ul>
</li>
</ol>
<div class="image">
<img src="datapath_2d_detailed_part1.png" alt="datapath_2d_detailed_part1.png"/>
<div class="caption">
2D-FFT Processing - Calculation of Detection Matrix and CFAR in Doppler direction</div></div>
<p><br />
<br />
</p><div class="image">
<img src="datapath_2d_timing.png" alt="datapath_2d_timing.png"/>
<div class="caption">
2D-FFT Processing - Calculation of Detection Matrix and CFAR in Doppler direction - timing diagram</div></div>
<p><br />
<br />
</p><div class="image">
<img src="datapath_2d_detailed_part2.png" alt="datapath_2d_detailed_part2.png"/>
<div class="caption">
CFAR in range direction and peak grouping</div></div>
 <h3><a class="anchor" id="peakGrouping"></a>
Peak grouping</h3>
<p>Two peak grouping schemes are implemented:</p><ol type="1">
<li>Peak grouping based on peaks of the neighboring bins read from detection matrix. For each CFAR detected peak, listed in <a class="el" href="struct_mmw_demo___d_s_s___data_path_obj__t.html#aaa3160824f96f19f2eb9add8c9acf718">MmwDemo_DSS_DataPathObj::detObj2DRaw</a>, it checks if the peak is greater than its neighbors. If this is true, the peak is copied to the output list of detected objects <a class="el" href="struct_mmw_demo___d_s_s___data_path_obj__t.html#aa77e508e8678e0cdbd9519fadc347eed">MmwDemo_DSS_DataPathObj::detObj2D</a>. The neighboring peaks that are used for checking are taken from the detection matrix <a class="el" href="struct_mmw_demo___d_s_s___data_path_obj__t.html#ad6aa74c1fd32e9757c66d15c8788ea48">MmwDemo_DSS_DataPathObj::detMatrix</a> and are copied into 3x3 kernel regardless of whether they are CFAR detected or not.</li>
<li>Peak grouping based on peaks of neighboring bins that are CFAR detected. For each detected peak the function checks if the peak is greater than its neighbors. If this is true, the peak is copied to the output list of detected objects. The neighboring peaks that are used for checking are taken from the list of CFAR detected objects, (not from the detection matrix), and are copied into 3x3 kernel that has been initialized to zero for each peak under test. If the neighboring peak has not been detected by CFAR, it is not copied into the kernel.</li>
</ol>
<p>Peak grouping schemes are illustrated in two figures below. The first figure, illustrating the first scheme, shows how the two targets (out of four) can be discarded and not presented to the output. For these two targets (at range indices 3 and 17 in figure below) the CFAR detector did not detect the highest peak of the target, but only some on the side, and these side peaks are discarded. The second figure, illustrating the second scheme, shows that all four targets are presented to the output, one peak per target, with the targets at range indices 3 and 17 represented with side peaks.</p>
<div class="image">
<img src="peak_grouping_based_on_detection_matrix.png" alt="peak_grouping_based_on_detection_matrix.png"/>
<div class="caption">
Peak grouping based on neighboring peaks from detection matrix</div></div>
<p><br />
</p><div class="image">
<img src="peak_grouping_based_on_cfar_detected_peaks.png" alt="peak_grouping_based_on_cfar_detected_peaks.png"/>
<div class="caption">
Peak grouping based on on neighboring CFAR detected peaks</div></div>
<p><br />
</p>
<h2><a class="anchor" id="dataAngElev"></a>
Data Path - Direction of Arrival FFT Calculation</h2>
<p>Because L3 memory is limited in size, the radar cube matrix stores only the 1D-FFT in 16-bit precision. Because of this, azimuth FFT calculation requires repeated 2D FFT calculation. Since for each detected object, we need 2D FFT at a single bin, instead of recalculating 2D-FFT, we calculate single point DFT at the bin index of each detected object. This calculation is repeated for each received antenna.</p>
<p>Compensation for the Doppler phase shift in the angle estimation is performed on the virtual antennas (symbols corresponding to the second Tx antenna in case of TDM-MIMO configuration). These symbols are rotated by half of the estimated Doppler phase shift between subsequent chirps from the same Tx antenna. The Doppler shift is calculated using the lookup table <a class="el" href="struct_mmw_demo___d_s_s___data_path_obj__t.html#a8c8cc4ff59d73dfa591c3bb8c238867c">MmwDemo_DSS_DataPathObj::azimuthModCoefs</a> Refer to the pictures below. <a class="anchor" id="Figure_doppler"></a> </p><div class="image">
<img src="angle_doppler_compensation_awr16.png" alt="angle_doppler_compensation_awr16.png"/>
<div class="caption">
Figure_doppler: Doppler Compensation</div></div>
<p> Currently the size of Azimuth FFT is hardcoded and defined by <a class="el" href="dss__main_8c.html#a95442efb4452ea2af94dd34f70ef5515">MMW_NUM_ANGLE_BINS</a>. The FFT is calculated using DSP lib function DSP_fft32x32. The output of the function is magnitude squared and the values are stored in floating point format.</p>
<div class="image">
<img src="datapath_azimuth_fft.png" alt="datapath_azimuth_fft.png"/>
<div class="caption">
Direction of arrival calculation</div></div>
<h2><a class="anchor" id="dataXYZ"></a>
Data Path - (X,Y) Estimation</h2>
<p>The (x,y) estimation is calculated in the function <a class="el" href="dss__data__path_8c.html#ae94ddda2f8e8e64df920b28b05ce8d71">MmwDemo_XYestimation</a>. <a class="anchor" id="Figure_geometry"></a> </p><div class="image">
<img src="coordinate_geometry.png" alt="coordinate_geometry.png"/>
<div class="caption">
Figure A: Coordinate Geometry</div></div>
<p> <br />
<a class="anchor" id="Figure_wx"></a> </p><div class="image">
<img src="coordinate_geometry_wx.png" alt="coordinate_geometry_wx.png"/>
<div class="caption">
Figure wx</div></div>
<p> <a class="el" href="index.html#Figure_geometry">Figure_geometry</a> shows orientation of x,y axes with respect to the sensor/antenna positions. The objective is to estimate the (x,y) coordinates of each detected object. <img class="formulaInl" alt="$w_x$" src="form_0.png"/> is the phase difference between consecutive receive azimuth antennas of the 2D FFT. The phases for each antenna are shown in the <a class="el" href="index.html#Figure_doppler">Figure_doppler</a>. <a class="el" href="index.html#Figure_wx">Figure_wx</a> shows that the distance AB which represents the relative distance between wavefronts intersecting consecutive azimuth antennas is <img class="formulaInl" alt="$AB = \frac{\lambda}{2} \sin (\theta)$" src="form_1.png"/>. Therefore <img class="formulaInl" alt="$w_x = \frac{2\pi}{\lambda} \cdot AB$" src="form_2.png"/>, and therefore <img class="formulaInl" alt="$w_x = \pi \sin (\theta)$" src="form_3.png"/>. Note that the phase of the left-ward antenna is advanced compared to the right-ward antenna and antenna indices increment from right to left (which is the order in ADCbuf and all of processing) so phase increments as <img class="formulaInl" alt="$+w_x$" src="form_4.png"/>. For a single obstacle, the signal at the 8 azimuth antennas will be ( <img class="formulaInl" alt="$A_1$" src="form_5.png"/> and <img class="formulaInl" alt="$\psi$" src="form_6.png"/> are the arbitrary starting amplitude/phase at the first antenna): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_1 e^{j\psi} [ 1 \; e^{jw_x} \; e^{j2w_x} \; e^{j3w_x} \; e^{j4w_x} \; e^{j5w_x} \; e^{j6w_x} \; e^{j7w_x} ] \]" src="form_7.png"/>
</p>
<p>An FFT of the above signal will yield a peak at <img class="formulaInl" alt="$w_x$" src="form_0.png"/> . If <img class="formulaInl" alt="$k_{MAX}$" src="form_8.png"/> is the index of the peak in log magnitude FFT represented as signed index in range <img class="formulaInl" alt="$[-\frac{N}{2}, \frac{N}{2}-1]$" src="form_9.png"/>, then <img class="formulaInl" alt="$ w_x $" src="form_10.png"/> will be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_x = \frac{2\pi}{N}k_{MAX} \]" src="form_11.png"/>
</p>
<p>Calculate range (in meters) as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R=k_r\frac{c \cdot F_{SAMP}}{2 \cdot S \cdot N_{FFT}} \]" src="form_12.png"/>
</p>
<p> where, <img class="formulaInl" alt="$c$" src="form_13.png"/> is the speed of light (m/sec), <img class="formulaInl" alt="$k_r$" src="form_14.png"/> is range index, <img class="formulaInl" alt="$F_{SAMP}$" src="form_15.png"/> is the sampling frequency (Hz), <img class="formulaInl" alt="$S$" src="form_16.png"/> is chirp slope (Hz/sec), <img class="formulaInl" alt="$N_{FFT}$" src="form_17.png"/> is 1D FFT size. Based on above calculations of <img class="formulaInl" alt="$R$" src="form_18.png"/> and <img class="formulaInl" alt="$w_x$" src="form_0.png"/>, the <img class="formulaInl" alt="$(x,y)$" src="form_19.png"/> position of the object can be calculated as seen in the <a class="el" href="index.html#Figure_geometry">Figure_geometry</a>, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = R\sin(\theta) = R\frac{w_x}{\pi}, y = \sqrt{R^2-x^2} \]" src="form_20.png"/>
</p>
<p> The computed <img class="formulaInl" alt="$(x,y)$" src="form_19.png"/> and azimuth peak for each object are populated in their respective positions in <a class="el" href="struct_mmw_demo___d_s_s___data_path_obj__t.html#aa77e508e8678e0cdbd9519fadc347eed">MmwDemo_DSS_DataPathObj::detObj2D</a>. Note the azimuth peak (magnitude squared) replaces the previous CFAR peak (sum of log magnitudes) in the structure. To be able to detect two objects at the same range-doppler index but at different angle, search for the 2nd peak in the azimuth FFT and compare its height relative to the first peak height, and if detected, create new object in the list with the same range/Doppler indices, and repeat above steps to calculate (x,y) coordinates. To enable/disable the two peak detection or to change the threshold for detection, refer to <a class="el" href="dss__main_8c.html#acab7c9fc6139e9d8192c8b9b8ed528ed">MMWDEMO_AZIMUTH_TWO_PEAK_DETECTION_ENABLE</a> and <a class="el" href="dss__main_8c.html#a518239edb48a7db80acedb6e20275cc6">MMWDEMO_AZIMUTH_TWO_PEAK_THRESHOLD_SCALE</a>.</p>
<h2><a class="anchor" id="velocityDisambiguation"></a>
Velocity disambiguation</h2>
<p>A simple technique for velocity disambiguation is implemented. It corrects target velocities up to <img class="formulaInl" alt="$2v_{max}$" src="form_21.png"/>, and allows for correct calculation of X/Y coordinates for target velocities even greater than <img class="formulaInl" alt="$2v_{max}$" src="form_21.png"/>. The technique consists of the following steps applied after the CFAR detection phase. For each detected point, assuming doppler correction of virtual antennas is already done:</p><ol type="1">
<li>Copy the doppler corrected antenna data A into the upper address area (labeled B in the figure below) of the azimuthIn. This is done because the DSPlib FFT function overwrites the input buffer with reversed index and we would need to later compute the FFT on sign flipped symbols corresponding to Tx2.</li>
<li>Calculate azimuth FFT (in area A) and compute the magnitude squared of the FFT output.</li>
<li>Save result azimuthMagSqr to set 0, "uncorrected set", (see figure below).</li>
<li>Flip the signs of the symbols corresponding to Tx2 antenna transmission in area B. Copy B to A and zero pad.</li>
<li>Repeat step 4.</li>
<li>Save result azimuthMagSqr to set 1, "corrected set".</li>
<li>Search for maximum over both sets, and select the set where the maximum occurred.</li>
<li><p class="startli">If the maximum occurred in "corrected set", correct the estimated velocity as:</p>
<p class="startli"><img class="formulaInl" alt="$ v_{corr} = v_{est} + 2v_{max}$" src="form_22.png"/> (if <img class="formulaInl" alt="$v_{est} &lt; 0$" src="form_23.png"/>)</p>
<p class="startli"><img class="formulaInl" alt="$ v_{corr} = v_{est} - 2v_{max}$" src="form_24.png"/> (if <img class="formulaInl" alt="$v_{est} &gt; 0$" src="form_25.png"/>)</p>
<p class="startli">otherwise no correction is required.</p>
</li>
<li><p class="startli">Calculate X/Y coordinates using index <img class="formulaInl" alt="$i_{max}$" src="form_26.png"/> from the selected set.</p>
<div class="image">
<img src="datapath_azimuth_fft_extnd_max_vel.png" alt="datapath_azimuth_fft_extnd_max_vel.png"/>
<div class="caption">
Extending maximum velocity - data path</div></div>
<p> Figure below illustrates this technique on one example with a target moving from the sensor at positive azimuth angle at a speed less than Vmax (case a), and at the speed greater than Vmax (case b). Figure shows 2D-FFT antenna symbols for 3 consecutive chirps: n, n+1 and n+2 (blue, green and red dots). The symbols of the chirp n and n+1 are used for azimuth FFT calculation. The Doppler shift, the angle <img class="formulaInl" alt="$\psi_{true}$" src="form_27.png"/> between chirps n and n+2, (successive chirps of the same Tx antenna), is estimated from 2D-FFT as <img class="formulaInl" alt="$\psi_{est}$" src="form_28.png"/>. In case a, <img class="formulaInl" alt="$\psi_{true} &lt; \pi$" src="form_29.png"/>, and <img class="formulaInl" alt="$\psi_{est} \approx \psi_{true}$" src="form_30.png"/>. In case b, <img class="formulaInl" alt="$\psi_{true} &gt; \pi$" src="form_31.png"/>, (Doppler velocity is aliased), and <img class="formulaInl" alt="$\psi_{est}$" src="form_28.png"/> is estimated as a negative value, (target approaching the sensor). Doppler compensation rotates the symbols of chirp n+1 by <img class="formulaInl" alt="$-\psi_{est}/2$" src="form_32.png"/> to align them with the symbols of chirp n. The azimuth FFT is calculated on these symbols, and the output is placed to set 0. The symbols of the chirp n+1 are then sign flipped, and the azimuth FFT is again calculated and the output is placed to set 1. In case a, V&lt;Vmax, the maximum peak in the FFT output in set 0 is larger than in set 1, as opposed in case b, V&gt;Vmax, where the maximum peak in FFT output in set 1 is larger than in set 0.</p>
</li>
</ol>
<div class="image">
<img src="extend_max_velocity.png" alt="extend_max_velocity.png"/>
<div class="caption">
Example of target moving from sensor under angle at V&lt;Vmax (Case a) and V&gt;Vmax (Case b)</div></div>
 <h2><a class="anchor" id="nearFieldCorrection"></a>
Near Field Correction</h2>
<h3><a class="anchor" id="nearFieldProblem"></a>
Problem Statement and Algorithm Description</h3>
<div class="image">
<img src="near_field_geometry.png" alt="near_field_geometry.png"/>
<div class="caption">
Near Field Geometry</div></div>
<p> It was assumed in <a class="el" href="index.html#dataXYZ">Data Path - (X,Y) Estimation</a> that the object was located in the far field so that the rays between the object and the multiple TX/RX antennas are parallel. However for very close by objects this assumption (of parallel lines) is not valid as seen in the above figure and can induce a significant phase error when processed using regular FFT techniques. It can be shown that:</p><ul>
<li>The phase error is most pronounced in the phase difference between the path from Tx1(C)-&gt;object(O)-&gt;Rx4(D) (red lines) and Tx2(A)-&gt;object(O)-&gt;Rx1(E) (green lines). This corresponds to the phase difference between virtual antenna 4 and 5</li>
<li>The phase error decreases as the range of the object increases.</li>
<li>For a fixed range, the phase error is most severe for bore-sight objects and decreases to zero at grazing angles.</li>
</ul>
<p>This phase error manifests in a spurious peak in the azimuth FFT which results in ghost object detection when multi object beam forming feature is enabled. In order to mitigate this error, the phase error between the physical and virtual sets of antennas needs to be corrected based on the geometry and the range at which the object has been detected. This is done in the following manner:</p>
<p>Let x be the 1x8 vector corresponding to the 8 virtual antennas. Let F denote the 64-point FFT of x; i.e F=fftshift (fft(x,64)); Similarly let <img class="formulaInl" alt="$F_1$" src="form_33.png"/> and <img class="formulaInl" alt="$F_2$" src="form_34.png"/> denote the 64-point FFT's of x(1:4) and x(5:8). Then it can be shown that: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ F(k) = F_1(k) + F_2(k) e^{-j 2 \pi k 4/64}; -32 \leq k \leq 31; \]" src="form_35.png"/>
</p>
<p> The above equation can be modified to incorporate the effect of the near-field induced phase error (which occurs at the boundary between the virtual antennas corresponding to TX1 and TX2). The modified equation is: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ F(k) = F_1(k) + F_2(k) e^{-j 2 \pi k 4/64} e^{- j \phi(k,r)}; -32 \leq k \leq 31; \]" src="form_36.png"/>
</p>
<p> where <img class="formulaInl" alt="$\phi(k,r)$" src="form_37.png"/> is the near-field induced phase error which depends on the angle <img class="formulaInl" alt="$k$" src="form_38.png"/> and range <img class="formulaInl" alt="$r$" src="form_39.png"/>. This quantity can be computed from the geometry in the above figure as follows:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \triangle OBC: tx1 = \sqrt{r^2 + \overline{\rm BC}^2 - 2 r \overline{\rm BC} \cos(\pi / 2 - \theta)} \]" src="form_40.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \triangle OBA: tx2 = \sqrt{r^2 + \overline{\rm BA}^2 - 2 r \overline{\rm BA} \cos(\pi / 2 + \theta)} \]" src="form_41.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \triangle OBD: rx4 = \sqrt{r^2 + \overline{\rm BD}^2 - 2 r \overline{\rm BD} \cos(\pi / 2 - \theta)} \]" src="form_42.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \triangle OBE: rx1 = \sqrt{r^2 + \overline{\rm BE}^2 - 2 r \overline{\rm BE} \cos(\pi / 2 - \theta)} \]" src="form_43.png"/>
</p>
<p>With <img class="formulaInl" alt="$theta = \arcsin(2k/64)$" src="form_44.png"/>, the above simplifies to:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ tx1 = \sqrt{r^2 + \overline{\rm BC}^2 - r k (\overline{\rm BC}/16)} \]" src="form_45.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ tx2 = \sqrt{r^2 + \overline{\rm BA}^2 - r k(-\overline{\rm BA}/16)} \]" src="form_46.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ rx4 = \sqrt{r^2 + \overline{\rm BD}^2 - r k(\overline{\rm BD}/16)} \]" src="form_47.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ rx1 = \sqrt{r^2 + \overline{\rm BE}^2 - r k(\overline{\rm BE}/16)} \]" src="form_48.png"/>
</p>
<p>Note that <img class="formulaInl" alt="$\overline{\rm BC}$" src="form_49.png"/>, <img class="formulaInl" alt="$\overline{\rm BA}$" src="form_50.png"/>, <img class="formulaInl" alt="$\overline{\rm BD}$" src="form_51.png"/>, <img class="formulaInl" alt="$\overline{\rm BE}$" src="form_52.png"/> are constants and therefore above calculations involve 4*(3 multiplications + 2 additions/subtractions + square root).</p>
<p>As mentioned in <a class="el" href="index.html#dataXYZ">Data Path - (X,Y) Estimation</a>, for far field the phase difference between consecutive antennas is <img class="formulaInl" alt="$w_x = \pi \sin(\theta)$" src="form_53.png"/>. So the phase error is calculated as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \phi(k,r) &amp;=&amp; \frac{2 \pi}{\lambda} \{(tx2 + rx1) - (tx1 + rx4)\} - \pi \sin(\theta) \\ &amp;=&amp; \frac{2 \pi}{\lambda} \{(tx2 + rx1) - (tx1 + rx4)\} - \pi k / 32 \end{eqnarray*}" src="form_54.png"/>
</p>
<h3><a class="anchor" id="nearFieldImplementation"></a>
Implementation Details</h3>
<div class="image">
<img src="near_field.png" alt="near_field.png"/>
<div class="caption">
Near Field Implementation</div></div>
<p> Referring to the figure above, for each detected point, assuming doppler correction of virtual antennas is already done:</p><ol type="1">
<li>Copy the antenna data corresponding to Tx2 to the upper address area (labeled B in the figure) of the azimuthIn and zero-pad between A (data for Tx1) and B. The purpose of this step is to preserve the Tx2 symbols for the next computation. Compute the FFT of the first 64 samples of azimuthIn and store in lower address (Set 0 in the picture) of azimuthOut. This is the <img class="formulaInl" alt="$F_1(k)$" src="form_55.png"/>.</li>
<li>Copy the Tx2 data stored at the upper address from above step into the position B shown in the lower path, which is basically restoring B back to its original position. Zero-pad the first 4 antennas (corresponding to Tx1) and zero-pad the remaining FFT input data after B. Compute the FFT of the first 64 samples of azimuthIn and store in upper address (Set 1 in the picture) of azimuthOut. This will be <img class="formulaInl" alt="$F_2(k) e^{-j 2 \pi k 4/64}$" src="form_56.png"/>.</li>
<li>Apply the correction <img class="formulaInl" alt="$e^{- j \phi(k,r)}$" src="form_57.png"/> on Set 1 over all <img class="formulaInl" alt="$k \in [-32,31)$" src="form_58.png"/> and add with Set 0 in place i.e output of the sum will replace Set 0.</li>
<li>Proceed to do the rest of the azimuth calculations (magnitude square etc).</li>
</ol>
<p>NOTE:</p><ol type="1">
<li>The range bias estimated from the calibration procedure is subtracted from the range at which object is detected before calculating the phase correction. The function to estimate the phase correction is <a class="el" href="dss__data__path_8c.html#a2486d8d5e2ad2159525494cf99f918ec">MmwDemo_nearFieldCorrection</a>.</li>
<li>The near field correction is currently in exclusion with velocity disambiguation because of implementation complexities and also because it is unlikely to have objects at high velocities in the near field.</li>
</ol>
<h3><a class="anchor" id="nearFieldintereface"></a>
User Interface</h3>
<p>A CLI command "nearFieldCfg" has been provided with parameters to enable/disable the feature and provide start and end range index over which the feature is to be activated. The phase error is highest at boresight ( <img class="formulaInl" alt="$\theta = 0$" src="form_59.png"/>). The following data at the boresight, which can be computed using the formulae in <a class="el" href="index.html#nearFieldProblem">Problem Statement and Algorithm Description</a>, can be used as a guidance to decide the maximum range up to which to enable the feature.</p>
<table class="doxtable">
<tr>
<th>Distance (cm) </th><th>Phase Error (degrees)  </th></tr>
<tr>
<td>5 </td><td>177.8 </td></tr>
<tr>
<td>10 </td><td>90.3 </td></tr>
<tr>
<td>20 </td><td>45.3 </td></tr>
<tr>
<td>40 </td><td>22.7 </td></tr>
<tr>
<td>80 </td><td>11.4 </td></tr>
<tr>
<td>100 </td><td>9.1 </td></tr>
<tr>
<td>200 </td><td>4.5 </td></tr>
<tr>
<td>400 </td><td>2.3 </td></tr>
<tr>
<td>1000 </td><td>0.9 </td></tr>
</table>
<p>NOTE:</p><ol type="1">
<li>The range index does not exclude the range bias. E.g if the range bias is 6 cm and the range step is 2 cm, then 4 cm from the sensor will be (6+4)/2 or 5 range bins or range index of 4.</li>
<li>Because of several computations involved in the near field correction for each detected point in the near field (most notably 64*(4 square root + 1 sin + 1 cosine)), the DSP will consume non-trivial MIPS for this feature. Presently it takes about 35000 cycles per detected point in the enabled near field range which is 58 us (at 600 MHz DSP speed).</li>
<li>Because of reasons not yet fully understood, the feature does not work reliably below about 5 cm and therefore is recommended to be disabled below this range (using the start index parameter of the configuration).</li>
<li>The near field correction is not applied on azimuth-range heatmap data shipped out of the target.</li>
</ol>
<h2><a class="anchor" id="subFrameSwitching"></a>
Sub-frame Switching for Advanced Frame</h2>
<p>There is some compute overhead for switching sub-frames beyond the book-keeping aspects for the data path object (which are multi-instantiated). Because of the potential resource constraints of EDMA (channels, params etc), and memory limitations, some computations are redone for each sub-frame depending on its configuration. These are:</p><ul>
<li>Reconfiguration of ADCbuf driver - <a class="el" href="dss__main_8c.html#a8b784104387aac58b145165bf148f2fd">MmwDemo_dssDataPathConfigAdcBuf</a></li>
<li>Reprogramming of the EDMA channels and Param sets - <a class="el" href="dss__data__path_8h.html#a9aae693edbaf62c314a5b6ca1d7e726c">MmwDemo_dataPathInitEdma</a></li>
<li>Regeneration of tables for FFT (twiddle tables), single-point DFT and FFT window - <a class="el" href="dss__data__path_8h.html#ab97f791dded56503d235a5deaf235dc2">MmwDemo_dataPathConfigFFTs</a>. This regeneration is particularly high in cycles if not optimized so certain optimizations were performed to efficiently generation these tables.</li>
</ul>
<p>One can see the cycles related to switching to the next sub-frame by examining in real-time mode the element <a class="el" href="struct_mmw_demo__timing_info.html#a8867cee851d3ea2aa833273c0e6fcaf5">MmwDemo_timingInfo::subFrameSwitchingCycles</a> in the data path object instance corresponding to the current sub-frame. Note that the buffer layout as described in section <a class="el" href="index.html#edma">EDMA versus Cache based Processing</a> is calculated during configuration time for all sub-frames corresponding to their configurations and so does not need to be part of sub-frame switching, because the memory savings related to not multiplying the buffer pointer storage for all sub-frames is modest. The above functions are called as part of a convenient reconfiguration function - <a class="el" href="dss__main_8c.html#ae8c127a8188f913553e5cfa1f95e3701">MmwDemo_dssDataPathReconfig</a>.</p>
<h2><a class="anchor" id="output"></a>
Output information sent to host</h2>
<p>Output packets with the detection information are sent out every frame through the UART. Each packet consists of the header <a class="el" href="struct_mmw_demo__output__message__header__t.html">MmwDemo_output_message_header_t</a> and the number of TLV items containing various data information with types enumerated in <a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314">MmwDemo_output_message_type_e</a>. The numerical values of the types can be found in <a class="el" href="mmw__output_8h.html">mmw_output.h</a>. Each TLV item consists of type, length (<a class="el" href="struct_mmw_demo__output__message__tl__t.html">MmwDemo_output_message_tl_t</a>) and payload information. The structure of the output packet is illustrated in the following figure. Since the length of the packet depends on the number of detected objects it can vary from frame to frame. The end of the packet is padded so that the total packet length is always multiple of 32 Bytes.</p>
<div class="image">
<img src="output_packet_uart.png" alt="output_packet_uart.png"/>
<div class="caption">
Output packet structure sent to UART</div></div>
<p> The following subsections describe the structure of each TLV.</p>
<h3><a class="anchor" id="tlv1"></a>
List of detected objects</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314ac896a2017ffbe63bf6bae47604ac3094">MMWDEMO_OUTPUT_MSG_DETECTED_POINTS</a>)</p>
<p>Length: (size of <a class="el" href="struct_mmw_demo__output__message__data_obj_descr__t.html">MmwDemo_output_message_dataObjDescr_t</a>) + (Number of detected objects) x (size of <a class="el" href="struct_mmw_demo__detected_obj__t.html">MmwDemo_detectedObj_t</a>)</p>
<p>Value: List descriptor (<a class="el" href="struct_mmw_demo__output__message__data_obj_descr__t.html">MmwDemo_output_message_dataObjDescr_t</a>) followed by array of detected objects. The information of each detected object is stored in structure <a class="el" href="struct_mmw_demo__detected_obj__t.html">MmwDemo_detectedObj_t</a>. When the number of detected objects is zero, this TLV item is not sent. The whole detected objects TLV structure is illustrated in figure below.</p>
<div class="image">
<img src="detected_objects_tlv.png" alt="detected_objects_tlv.png"/>
<div class="caption">
Detected objects TLV</div></div>
<p> Note: If user is interested in parsing the UART stream to find range and velocity from their indices in the structure <a class="el" href="struct_mmw_demo__detected_obj__t.html">MmwDemo_detectedObj_t</a> in meters and meters/second respectively, then refer to the following:</p><ol type="1">
<li>In order to convert range index to range in meters, use the range formula mentioned in <a class="el" href="index.html#dataXYZ">Data Path - (X,Y) Estimation</a>, where <img class="formulaInl" alt="$R$" src="form_18.png"/> is the range and <img class="formulaInl" alt="$k_r$" src="form_14.png"/> is the range index. In terms of CLI's profile configuration: <br />
 range in m = range index * (speed of light(3e8) * (digOutSampleRate * 1e3) / (2 * (freqSlopeConst * (1e6/1e-6)) * numRangeBins)) - range bias <br />
 where the parameter names digOutSampleRate (ksps) and freqSlopeConst (MHz/us) are defined in CLI's profile configuration. Range bias is in meters and measured using the procedure described in <a class="el" href="index.html#calibration">Range Bias and Rx Channel Gain/Offset Measurement and Compensation</a>.</li>
<li>In order to convert doppler index to velocity in meters/sec, <br />
 velocity in m/s = doppler index * ( speed of light(3e8) / (2 * (startFreq * 1e9) * ((idleTime + rampEndTime) * 1e-6) * numChirpsPerFrame) ) <br />
 where the parameter names startFreq (GHz), idleTime (us) and rampEndTime (us) above are described in CLI's profile configuration. and numChirpsPerFrame is the total number of physical chirps in one frame [the quantity (idleTime + rampEndTime) * numChirpsPerFrame therefore represents the total chirping duration in a frame]. This quantity is related to profile configuration as follows: <br />
 numChirpsPerFrame = (chirp end index - chirp start index + 1) * numLoops, the parameters are from frame configuration (frameCfg). <br />
 If using advanced frame feature, then <br />
 numChirpsPerFrame = numOfChirps * numLoops, the parameters are from sub-frame configuration (subFrameCfg). <br />
 Note doppler index is signed as documented in <a class="el" href="struct_mmw_demo__detected_obj__t.html">MmwDemo_detectedObj_t</a> so velocity in m/s will also be signed. Positive velocity means target is moving away from the sensor and negative velocity means target is moving towards the sensor.</li>
</ol>
<h3><a class="anchor" id="tlv2"></a>
Range profile</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314a8379a0f322cdf98d72de0d29c613972b">MMWDEMO_OUTPUT_MSG_RANGE_PROFILE</a>)</p>
<p>Length: (Range FFT size) x (size of uint16_t)</p>
<p>Value: Array of profile points at 0th Doppler (stationary objects). In XWR16xx the points represent the sum of log2 magnitudes of received antennas, expressed in Q8 format. In XWR14xx the points represent the average of log2 magnitudes of received antennas, expressed in Q9 format.</p>
<h3><a class="anchor" id="tlv3"></a>
Noise floor profile</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314a2f22cc4380702439ad5d161154daa135">MMWDEMO_OUTPUT_MSG_NOISE_PROFILE</a>)</p>
<p>Length: (Range FFT size) x (size of uint16_t)</p>
<p>Value: This is the same format as range profile but the profile is at the maximum Doppler bin (maximum speed objects). In general for stationary scene, there would be no objects or clutter at maximum speed so the range profile at such speed represents the receiver noise floor.</p>
<h3><a class="anchor" id="tlv4"></a>
Azimuth static heatmap</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314aa9eb23150e2b2e0a4d4dd0483250648d">MMWDEMO_OUTPUT_MSG_AZIMUT_STATIC_HEAT_MAP</a>)</p>
<p>Length: (Range FFT size) x (Number of virtual antennas) (size of <a class="el" href="structcmplx16_im_re__t__.html">cmplx16ImRe_t_</a>)</p>
<p>Value: Array <a class="el" href="struct_mmw_demo___d_s_s___data_path_obj__t.html#a082e171ea46242db218305f42648b79d">MmwDemo_DSS_DataPathObj::azimuthStaticHeatMap</a>. The antenna data are complex symbols, with imaginary first and real second in the following order:<br />
</p><pre class="fragment">         Imag(ant 0, range 0), Real(ant 0, range 0),...,Imag(ant N-1, range 0),Real(ant N-1, range 0)
         ...
         Imag(ant 0, range R-1), Real(ant 0, range R-1),...,Imag(ant N-1, range R-1),Real(ant N-1, range R-1)</pre><p> Based on this data the static azimuth heat map is constructed by the GUI running on the host.</p>
<h3><a class="anchor" id="tlv5"></a>
Range/Doppler heatmap</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314aa27e45d8b27b239cd9cf30e95b616822">MMWDEMO_OUTPUT_MSG_RANGE_DOPPLER_HEAT_MAP</a>)</p>
<p>Length: (Range FFT size) x (Doppler FFT size) (size of uint16_t)</p>
<p>Value: Detection matrix <a class="el" href="struct_mmw_demo___d_s_s___data_path_obj__t.html#ad6aa74c1fd32e9757c66d15c8788ea48">MmwDemo_DSS_DataPathObj::detMatrix</a>. The order is : <br />
</p><pre class="fragment">        X(range bin 0, Doppler bin 0),...,X(range bin 0, Doppler bin D-1),
        ...
        X(range bin R-1, Doppler bin 0),...,X(range bin R-1, Doppler bin D-1)</pre><h3><a class="anchor" id="tlv6"></a>
Stats information</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314ae2e666ace315e23b261eb87cacc225b5">MMWDEMO_OUTPUT_MSG_STATS</a> )</p>
<p>Length: (size of <a class="el" href="struct_mmw_demo__output__message__stats__t.html">MmwDemo_output_message_stats_t</a>)</p>
<p>Value: Timing information enclosed in <a class="el" href="struct_mmw_demo__output__message__stats__t.html">MmwDemo_output_message_stats_t</a>. The following figure describes them in the timing diagram.</p>
<div class="image">
<img src="margins_xwr16xx.png" alt="margins_xwr16xx.png"/>
<div class="caption">
Margins and DSS CPU loading</div></div>
<p> The CLI command "guMonitor" specifies which TLV element will be sent out within the output packet. The arguments of the CLI command are stored in the structure <a class="el" href="struct_mmw_demo___gui_mon_sel__t.html">MmwDemo_GuiMonSel_t</a>.</p>
<h3><a class="anchor" id="dss_to_mss_packet"></a>
DSS to MSS packet structure</h3>
<p>The packet construction is initiated on DSS side at the end of interframe processing. The packet is sent from DSS to MSS via mailbox. The structure of the packet on the mailbox is illustrated in the following figure. The packet header is followed by the number of TLV elements (<a class="el" href="struct_mmw_demo__msg_tlv__t.html">MmwDemo_msgTlv_t</a>) where the address fields of these elements point to payloads located either in HS-RAM or in L3 memory.</p>
<div class="image">
<img src="output_packet_dss_to_mss.png" alt="output_packet_dss_to_mss.png"/>
<div class="caption">
Output packet structure sent from DSS to MSS</div></div>
 <h2><a class="anchor" id="calibration"></a>
Range Bias and Rx Channel Gain/Offset Measurement and Compensation</h2>
<p><a class="anchor" id="Figure_calibration"></a> </p><div class="image">
<img src="rx_ch_calibration.png" alt="rx_ch_calibration.png"/>
<div class="caption">
Measurement and compensation of range bias and Rx channel gain/offset</div></div>
<p> Because of imperfections in antenna layouts on the board, RF delays in SOC, etc, there is need to calibrate the sensor to compensate for bias in the range estimation and receive channel gain and phase imperfections. The calibration procedure is as follows:</p>
<ol type="1">
<li>Set a strong target like corner reflector at the distance of X meter (X less than 50 cm is not recommended) at boresight.</li>
<li>Set the following command in the configuration profile in .../demo/xwr16xx/mmw/profiles/profile_calibration.cfg, to reflect the position X as follows: <pre class="fragment">   measureRangeBiasAndRxChanPhase 1 X D</pre> where D (in meters) is the distance of window around X where the peak will be searched. The purpose of the search window is to allow the test environment from not being overly constrained say because it may not be possible to clear it of all reflectors that may be stronger than the one used for calibration. The window size is recommended to be at least the distance equivalent of a few range bins. One range bin for the calibration profile (profile_calibration.cfg) is about 5 cm. The first argument "1" is to enable the measurement. The stated configuration profile (.cfg) must be used otherwise the calibration may not work as expected (this profile ensures all transmit and receive antennas are engaged among other things needed for calibration).</li>
<li>Start the sensor with the configuration file.</li>
<li>To estimate the range bias, peak search is done after the 2D FFT in the 0th Doppler of the detection matrix. The peak position is then used to compute the square root of the sum of the magnitude squares of the virtual antennas (taken from <a class="el" href="struct_mmw_demo___d_s_s___data_path_obj__t.html#a082e171ea46242db218305f42648b79d">MmwDemo_DSS_DataPathObj::azimuthStaticHeatMap</a>) for the peak and its two nearest neighbors. These 3 magnitudes and their positions are used to do parabolic interpolation to find the more accurate peak from which the range bias is estimated as peak - X. The rx channel phase and gain estimation is done by finding the minimum of the magnitude squared of the virtual antennas and this minimum is used to scale the individual antennas so that the magnitude of the coefficients is always less than or equal to 1. The complex conjugate of the samples scaled in this way is stored in a common storage area (common across sub-frames) in Q15 format (<a class="el" href="struct_mmw_demo___cli_common_cfg__t__.html#a2942e8f2327e8ce0e748f983da017d7a">MmwDemo_CliCommonCfg_t::compRxChanCfg</a>). Refer to the function <a class="el" href="rx__ch__bias__measure_8h.html#a09613f4705655b713984d8448264d1e3">MmwDemo_rangeBiasRxChPhaseMeasure</a> which performs the measurements and as seen in the above picture, the measurement results are written out on the CLI port in the format below: <pre class="fragment">   compRangeBiasAndRxChanPhase &lt;rangeBias&gt; &lt;Re(0,0)&gt; &lt;Im(0,0)&gt; &lt;Re(0,1)&gt; &lt;Im(0,1)&gt; ... &lt;Re(0,R-1)&gt; &lt;Im(0,R-1)&gt; &lt;Re(1,0)&gt; &lt;Im(1,0)&gt; ... &lt;Re(T-1,R-1)&gt; &lt;Im(T-1,R-1)&gt;</pre></li>
<li>The command printed out on the CLI now can be copied and pasted in any configuration file for correction purposes. During the parsing of the configuration file, based on the antenna profile, the measurement result stored as described in previous step in the common storage is copied to individual sub-frame data path object (each sub-frame may have separate configuration) so that all antennas enabled for that configuration are contiguous in storage as seen in the example shown in picture <a class="el" href="index.html#Figure_calibration">Figure_calibration</a>. This contiguous storage of the samples themselves as opposed to storing indices to look-up into the common (full) storage is required for computational efficiency in the DSP. that is used during angle estimation to apply the correction by multiplying the received samples with the stored conjugate numbers. If compensation is not desired, the following command should be given <pre class="fragment">   compRangeBiasAndRxChanPhase 0.0   1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0</pre> Above sets the range bias to 0 and the phase coefficients to unity so that there is no correction. Note the two commands must always be given in any configuration file, typically the measure commmand will be disabled when the correction command is the desired one.</li>
</ol>
<h2><a class="anchor" id="bpmCfgNotes"></a>
BPM Scheme</h2>
<p>Similar to TDM-MIMO, in BPM scheme a frame consists of multiple blocks, each block consisting of 2 chirp intervals. However, unlike in TDM-MIMO where only one TX antenna active per chirp interval, both Tx antennas are active in each chirp interval (see figure below).<br />
 </p><div class="image">
<img src="bpm_antenna_cfg.png" alt="bpm_antenna_cfg.png"/>
<div class="caption">
BPM Scheme Antenna configuration</div></div>
<p> Let S1 and S2 represent chirp signals from two Tx antennas. In the first interval a combined signal Sa=S1+S2 is transmitted. Similarly in the second interval a combined signal Sb=S1-S2 is transmitted. Using the corresponding received signals, (S'a and S'b), at a specific received RX antenna, the components from the individual transmitters are separated out using S'1=(S'a+S'b)/2 and S'2=(S'a-S'b)/2.<br />
 With simultaneous transmission on both Tx antennas the total transmitted power per chirp interval is increased, and it can be shown that this translates to an SNR improvement of 3dB.<br />
</p>
<h2><a class="anchor" id="bpmNotes"></a>
Data Path changes for BPM</h2>
<p>When BPM is enabled the following changes are done in the data path. </p>
<h3><a class="anchor" id="BPM_2d"></a>
2D Processing changes for BPM:</h3>
<p>In the 2D processing chain, when BPM is enabled, Doppler compensation and BPM decoding are done after the 2D FFT. Note that the decoded data is not stored in the radar cube, therefore BPM decoding needs to be done again (on a much smaller set of samples) during the direction of arrival computation. The following figure shows the required changes in the 2D processing. When BPM is enabled the fftOut2D buffer is doubled in size to accommodate both Ping (Tx1+Tx2) and Pong (Tx1-Tx2) so that BPM can be decoded.</p>
<div class="image">
<img src="bpm_2d_changes.png" alt="bpm_2d_changes.png"/>
<div class="caption">
2D processing changes for BPM</div></div>
 <h3><a class="anchor" id="BPM_3d"></a>
Direction of Arrival Processing changes for BPM:</h3>
<p>In the direction of arrival processing, when BPM is enabled, Doppler compensation and BPM decoding are done after the 2D FFT and before the azimuth FFT. The following figure shows the required changes in the direction of arrival processing.</p>
<div class="image">
<img src="direction_of_arrival_BPM.png" alt="direction_of_arrival_BPM.png"/>
<div class="caption">
Direction of arrival computation changes for BPM</div></div>
 <h2><a class="anchor" id="designNotes"></a>
Data Path Design Notes</h2>
<h3><a class="anchor" id="cfar"></a>
CFAR processing:</h3>
<p>For most scenarios, detection along range dimension is likely to be more difficult (clutter) than detection along the Doppler dimension. For e.g a simple detection procedure (CFAR-CA) might suffice in the Doppler dimension, while detection along range dimension might require more sophisticated algorithms (e.g. CFAR-OS, histogram based or other heuristics). So detection along Doppler dimension first might be computationally cheaper: the first selection algorithm is less complex, and the subsequent more sophisticated algorithm runs only on the points detected by the first algorithm. So in this implementation, we run Doppler CFAR first and then run range CFAR on the detected Doppler indices. However, we currently use the same type of algorithm (CFAR-CA) for the range direction as the Doppler direction. The range CFAR algorithm could be replaced by a more sophisticated algorithm like CFAR-OS to get the benefit of this way of processing. </p>
<h3><a class="anchor" id="scaling"></a>
Scaling</h3>
<p>Most of the signal processing in the data path that happens in real-time in 1D and 2D processing uses fixed-point arithmetic (versus floating point arithmetic). While the C647X is natively capable of both fixed and floating, the choice here is more for MIPS optimality but using fixed-point requires some considerations for preventing underflow and overflow while maintaining the desired accuracy required for correct functionality.</p><ul>
<li>1D processing: If the input to the FFT were a pure tone at one of the bins, then the output magnitude of the FFT at that bin will be <img class="formulaInl" alt="$N / \lceil2^{log_4(N)-1}\rceil$" src="form_60.png"/> ( <img class="formulaInl" alt="$N$" src="form_61.png"/> is the FFT order) times the input tone amplitude (because tone is complex, this implies that the individual real and imaginary components will also be amplified by a maximum of this scale). Because we do a Blackman window before the FFT, the overall scale is 0.42 of the FFT scale. For simplicity we will assume worst scale of 0.5 (this will be the case if someone choose Hanning window for example for 1D). This means for example for 256 point FFT, the windowing + FFT scale will be 16. Therefore, the ADC output when it is a pure tone should not exceed +/-2^15/16 = 2048 for the I and Q components. The XWR16xx EVM when presented with a strong single reflector reasonably close to it (with Rx dB gain of 30 dB in the chirp profile) shows ADC samples to be a max of about 3000 and while this exceeds the 2048 maximum, is not a pure tone, the energy of the FFT is seen in other bins also and the solution still works well and detects the strong object.</li>
<li>2D processing: For the 2D FFT, given that the input is the output of 1D FFT that can amplify its input as mentioned in previous section, it is more appropriate to use a 32x32 FFT which helps prevent overflow and reduce quantization noise of the FFT.</li>
</ul>
<h3><a class="anchor" id="edma"></a>
EDMA versus Cache based Processing</h3>
<p>The C647X has L1D cache which is enabled and processing can be done without using EDMA to access the L2 SRAM and L3 memories through cache. However, the latency to L3 RAM is much more than L2SRAM and this causes cycle waits that are avoided by using EDMA to prefetch or postcommit the data into L2SRAM. The L1D is configured part cache (16 KB) and part SRAM (16 KB). Presently the L3 RAM is not declared as cacheable (i.e the MAR register settings are defaulted to no caching for L3 RAM). Various buffers involved in data path processing are placed in L1SRAM and L2SRAM in a way to optimize memory usage by overlaying between and within 1D, 2D and 3D processing stages. The overlay choices are based on a variety of configurations that this demo supports, so the choice may not necessarily be optimal for a specific/known configuration. The overlays are documented in the comments in the body of the function <a class="el" href="dss__data__path_8h.html#a46add3bbd4290ec0f4d11b5748dc756a">MmwDemo_dataPathConfigBuffers</a> and can be disabled using a compile time flag for debug purposes. The function uses a macro <a class="el" href="dss__data__path_8c.html#aeed2eead12d938795226fda585c8e81e">MMW_ALLOC_BUF</a> to facilitate expressing the cascading and parallelization of buffers. It creates a local variable &lt;name&gt;_end automatically to be used for subsequent cascaded allocation. Figure below also documents the same overlay scheme. The figure is not to scale as actual sizes will vary based on configuration.</p>
<div class="image">
<img src="data_buffers_overlay_org.png" alt="data_buffers_overlay_org.png"/>
<div class="caption">
Data buffers overlay arrangement</div></div>
 <h2><a class="anchor" id="LVDSStreamingNotes"></a>
Streaming data over LVDS</h2>
<p>The LVDS streaming feature enables the streaming of HW data (a combination of ADC/CP/CQ data) and/or user specific SW data through LVDS interface. The streaming is done mostly by the CBUFF and EDMA peripherals with minimal CPU intervention. The streaming is configured through the lvdsStreamCfg CLI command. The LVDS streaming configuration includes the following 3 items:<br />
<br />
 a) Enable/Disable HSI header. This controls if HSI header is enabled or disabled for all active streams (HW and/or SW). Note that if SW stream is enabled HSI header must be enabled.<br />
<br />
 b) HW streaming data format. This controls which type of HW data will be streamed (ADC/CP/CQ). The following values are allowed for this field<br />
 0 - HW streaming disabled<br />
 1 - ADC data streamed<br />
 2 - CP_ADC data streamed<br />
 3 - ADC_CP data streamed<br />
 4 - CP_ADC_CQ data streamed<br />
<br />
 c) Enable/Disable SW streaming.<br />
<br />
 When HW data LVDS streaming is enabled the ADC/CP/CQ data is streamed per chirp as soon as the data is available in the HW buffers. When SW data streaming is enabled, it is streamed during inter frame period after the list of detected objects for that frame is computed. The SW data streamed is composed of 3 blocks:<br />
 i) HSI header (<a class="el" href="struct_h_s_i_header__t.html">HSIHeader_t</a>): refer to HSI module for details.<br />
 ii) User data header: contains the frame number, number of detected objects and 2 reserved bytes <a class="el" href="struct_mmw_demo___l_v_d_s_user_data_header.html">MmwDemo_LVDSUserDataHeader</a> <br />
 iii) List of detected objects in that frame (one instance of <a class="el" href="struct_mmw_demo__detected_obj__t.html">MmwDemo_detectedObj_t</a> per detected object).<br />
<br />
 The format of the SW data streamed is shown in the following figure:</p>
<div class="image">
<img src="lvds_sw_data_format.png" alt="lvds_sw_data_format.png"/>
<div class="caption">
LVDS SW Data format</div></div>
<p> The following figure shows a timing diagram for the LVDS streaming (the figure is not to scale as actual durations will vary based on configuration).</p>
<div class="image">
<img src="lvdstiming.png" alt="lvdstiming.png"/>
<div class="caption">
LVDS timing diagram</div></div>
 <h1><a class="anchor" id="memoryUsage"></a>
Memory Usage</h1>
<h2><a class="anchor" id="memUsageSummaryMSS"></a>
MSS Memory usage summary</h2>
<p>The table below shows the usage of various memories available on the device's MSS across the demo application and other SDK components. The table is generated using the demo's MSS map file and applying some mapping rules to it to generate a condensed summary. For the mapping rules, please refer to <a href="../../demo_mss_mapping.txt">demo_mss_mapping.txt</a>. The numeric values shown here represent bytes. Refer to the <a href="../../xwr16xx_mmw_demo_mss_mem_analysis_detailed.txt">xwr16xx_mmw_demo_mss_mem_analysis_detailed.txt</a> for detailed analysis of the memory usage across drivers and control/alg components and to <a href="../../demo_mss_mapping_detailed.txt">demo_mss_mapping_detailed.txt</a> for detailed mapping rules.</p>
<div class="fragment"><div class="line">                                   OVERVIEW                                    </div><div class="line">Memory                              Used               Total        Percent Used</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">DATA_RAM                           59600              196608              30.31%</div><div class="line">HS_RAM                                 0               32768               0.00%</div><div class="line">L3_RAM                                 0              786432               0.00%</div><div class="line">PROG_RAM                           85898              261888              32.80%</div><div class="line">VECTORS                               60                 256              23.44%</div><div class="line"></div><div class="line"></div><div class="line">                            Type           DATA_RAM       HS_RAM       L3_RAM     PROG_RAM      VECTORS</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">APP                         code              10420            0            0        36994           60</div><div class="line">APP                         heap              43008            0            0            0            0</div><div class="line">BIOS                        code                  0            0            0        20547            0</div><div class="line">COMPONENTS_CORE             code               1496            0            0        22810            0</div><div class="line">COMPONENTS_OPTIONAL         code                580            0            0         4134            0</div><div class="line">linker-generated            linker             4096            0            0          475            0</div><div class="line">linker-generated            unknown               0            0            0          938            0</div></div><!-- fragment --><h2><a class="anchor" id="memUsageSummaryDSS"></a>
DSS Memory usage summary</h2>
<p>The table below shows the usage of various memories available on the device's DSS across the demo application and other SDK components. The table is generated using the demo's DSS map file and applying some mapping rules to it to generate a condensed summary. For the mapping rules, please refer to <a href="../../demo_dss_mapping.txt">demo_dss_mapping.txt</a>. The numeric values shown here represent bytes. Refer to the <a href="../../xwr16xx_mmw_demo_dss_mem_analysis_detailed.txt">xwr16xx_mmw_demo_dss_mem_analysis_detailed.txt</a> for detailed analysis of the memory usage across drivers and control/alg components and to <a href="../../demo_dss_mapping_detailed.txt">demo_dss_mapping_detailed.txt</a> for detailed mapping rules.</p>
<div class="fragment"><div class="line">                                   OVERVIEW                                    </div><div class="line">Memory                              Used               Total        Percent Used</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">PAGE 0:</div><div class="line">HSRAM                              32768               32768             100.00%</div><div class="line">L1DSRAM                            16384               16384             100.00%</div><div class="line">L1PSRAM                            15232               16384              92.97%</div><div class="line">L2SRAM_UMAP0                      118689              131072              90.55%</div><div class="line">L2SRAM_UMAP1                      131072              131072             100.00%</div><div class="line">L3SRAM                              2176              786432               0.28%</div><div class="line">PAGE 1:</div><div class="line">L3SRAM                            786432              786432             100.00%</div><div class="line"></div><div class="line"></div><div class="line">                            Type              HSRAM      L1DSRAM      L1PSRAM L2SRAM_UMAP0 L2SRAM_UMAP1       L3SRAM</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">ALG                         code                  0            0         6944           64           96            0</div><div class="line">APP                         code                  0            0         8208        24143        53616         1648</div><div class="line">APP                         heap              32768        16384            0        72712            0       786432</div><div class="line">BIOS                        code                  0            0           16         7480        25600           48</div><div class="line">COMPONENTS_CORE             code                  0            0           48        10896        33952          480</div><div class="line">COMPONENTS_OPTIONAL         code                  0            0            0         1588        17792            0</div><div class="line">linker-generated            linker                0            0           16         1806           16            0</div></div><!-- fragment --><h2>Note on L3 memory and overlay </h2>
<p>A quick look at the L3_SRAM column will show that the total of that column exceeds the total physical memory available on the device. The reason is that we use the code-data overlay mechanism to virtually extend the available memory on the device. One-time startup code is overlaid with the radar cube. At startup, the application code accesses these functions to perform one-time setup functionality. Beyond that point, application code does not have a need to access these functions again and hence switches to access radarCube placed at the exact same location. Refer to the linker command file of the demo on the mechanics of this overlay technique.</p>
<h2>L1P/L3 overlay in 16xx DSS </h2>
<p>Currently bootloader does not allow loading in L1PSRAM and hence we use the overlay and copy table functionality of the linker to specify the load address as L3_SRAM but run address as L1P_SRAM for some of the functions that have time-critical operations (for e.g., mmWaveLib functions). In the table we show such functions as placed in L1P_SRAM and do not show it under L3_SRAM column since the startup code takes care of copying from L3_SRAM and placing it in L1P_SRAM and that memory in L3_SRAM is available for use for other purposes. </p>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
